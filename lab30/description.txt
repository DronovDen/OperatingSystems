Сокет – файловый дескриптор специального типа. Сокеты могут использоваться для связи между процессами, как
находящимися на одной машине, так и на разных(по сети).
Сокеты предоставляют более удобный протокол установления соединения, чем трубы.
Потоковые сокеты похожи на трубы и передают поток байтов между процессами.
Пакетные (датаграммные) сокеты передают пакеты (датаграммы).

• Запись в закрытый сокет – SIGPIPE
• Чтение из закрытого сокета – конец файла

создаем структуру типа sockaddr_un, описывающую адрес сокета сервера
struct sockaddr_un { /* AF_UNIX */
    sa_family_t sun_family; /* address family */
    char sun_path[108]; /* socket pathname */ 
};

Имя — это адрес в коммуникационном пространстве сокета

При любых моделях связи клиент и сервер должны создать сокеты, которые являются дескрипторами, используемыми 
для установки связи между процессами в сети. Они создаются при помощи системного вызова socket.
int socket(int domain, int type, int protocol);
Возвращает:
-1 – ошибка
>=0 – файловый дескриптор сокета
Параметр domain определяет коммуникационный домен, в котором будет использоваться сокет. 
Значение AF_INET определяет, что будет использоваться домен Internet.
AF_UNIX используется, если процессы находятся на одном и том же компьютере.
Параметр type определяет тип создаваемого сокета. Значение SOCK_STREAM
указывается, что будет использоваться TCP-соединение, а значение SOCK_DGRAM – для работы в режиме 
пересылок дейтаграмм. Последний параметр protocol определяет используемый протокол. Этот параметр обычно
задается равным нулю, при этом по умолчанию сокет типа SOCK_STREAM(Ориентированы на создание логического соединения, упорядоченность
передачи данных, гарантируется доставка сообщений) будет использовать протокол TCP, 
а сокет типа SOCK_DGRAM – протокол UDP.

#========CLIENT========#
int connect(int s, const struct sockaddr* address, int add_len);
Устанавливает соединение с заданным сервером
Возвращает: 
-1 - ошибка
 0 - завершился успешно
Первый параметр s является дескриптором сокета клиента. Параметр address указывает на
структуру, содержащую адрес сервера, параметр add_len определяет размер используемой структуры адреса.
Для установления соединения посылается пакет и ожидается соответствующий ответ от сервера с подтверждением.
Попытка соединения с сервером может потерпеть неудачу по нескольким причинам.
Машина, с которой устанавливается соединение, должна быть включена и связана с сетью(если сетевое взаимодействие).
Серверу должен быть присвоен адрес, с которым мы пытаемся соединиться, и в очереди запросов на соединение на стороне сервера должно 
быть достаточно места, чтобы поставить в очередь наш запрос.
Если функция connect терпит неудачу, процесс повторяет попытку, всякий раз увеличивая время задержки ожидания ответа сервера, пока
оно не достигнет максимума.

• Устанавливает соединение с заданным сервером
• Возвращает успех/неуспех
• При успехе, s можно использовать для передачи данных 

Unix domain sockets
• Только SOCK_STREAM
• Право на присоединение регулируется правами доступа к файлу
• После завершения сервера, файл сокета сам не удаляется
• Это может помешать повторному bind(3SOCKET)
• Используйте unlink(2)

#========SERVER========#
bind - присваиваем адрес к сокету
Адрес, присваиваемый клиентскому сокету, указывать необязательно, потому мы можем позволить системе выбирать 
адрес по умолчанию. Но для сервера важно присвоить сокету предопределенный адрес, на который клиенты
будут присылать запросы. Клиентам необходимо заранее знать требуемый адрес, чтобы войти в контакт с сервером.
Первый параметр, sockfd, является дескриптором файла сокета, созданный с помощью вызова socket, 
а второй – указателем на обобщенную структуру адреса сокета. Последний параметр содержит размер указанной структуры адреса 
сокета. В случае успешного завершения вызова bind он возвращает значение 0. В случае ошибки, вызов bind возвращает значение -1.

Функция bind() присваивает имя безымянному сокету. Когда сокет создается с помощью socket(3SOCKET),
он существует в пространстве имен (семействе адресов), но ему не назначено имя. Функция bind() запрашивает,
чтобы имя, на которое указывает name, было назначено сокету.

После вызова функции listen указанный сокет будет использоваться для приема запросов на соединение.
int listen(int sockfd, int queue_size)
Параметр sockfd имеет то же значение, что и в предыдущем вызове. В очереди сервера может находиться не более 
queue_size запросов на соединение. После заполнения очереди система будет отвергать дополнительные запросы на
соединение. 
• Регистрирует серверный сокет
• Сокет должен быть предварительно привязан
• Больше ничего не происходит (не блокируется)

Если запрос на подключение поступает с заполненной очередью, клиент получит сообщение об ошибке с указанием ECONNREFUSED
для сокетов AF_UNIX. Если базовый протокол поддерживает повторную передачу, запрос на подключение может быть проигнорирован, 
чтобы повторные попытки могли завершиться успешно. Для сокетов AF_INET и AF_INET6 TCP повторит попытку подключения.
Если отставание не будет устранено к моменту истечения времени ожидания tcp, соединение завершится ошибкой с помощью ETIMEDOUT.

int accept(int sockfd, struct sockaddr *address, size_t *add_len)
Функция accept возвращает дескриптор сокета, соединенного с клиентом, вызвавшим функцию connect. 
Этот новый сокет имеет тот же тип и семейство адресов что и сокет sockfd. 
Первоначальный сокет, который передается функции accept, не связан с установленным соединением, он остается свободным для приема по-
следующих запросов на соединение.
Когда сервер получает от клиента запрос на соединение, он должен создать
новый сокет для работы с новым соединением. 
Системному вызову accept передается дескриптор сокета, для которого ведется прием соединений. 
Параметр address заполняется информацией о клиенте. Так как связь использует соединение, адрес клиента
знать не обязательно, поэтому можно присвоить параметру address значение NULL. 
Если значение address не равно NULL, то переменная, на которую указывает параметр add_len, 
первоначально должна содержать размер структуры адреса, заданной параметром address. 

• Блокируется в ожидании входящего соединения
• address – это адрес клиента, установившего соединение
• Может вызываться многократно
• Возвращает новый сокет, который можно использовать для передачи
данных

Закрываются сокеты так же, как и обычные дескрипторы файлового ввода/
вывода, – при помощи системного вызова close. Для сокета типа SOCK_STREAM
ядро гарантирует, что все записанные в сокет данные будут переданы принимаю
щему процессу. Если сокет имеет тип SOCK_DGRAM, то
сокет закрывается немедленно.

При использовании интерфейса дейтаграмм (SOCK_DGRAM) не требуется устанавливать логическое соединение, 
чтобы обмениваться данными между конечными точками взаимодействия. Все, что нужно сделать, - передать сообщение 
по адресу сокета, который используется процессом на другом конце.

При работе с сокетами важно корректно реагировать на завершение работы
абонентского процесса. Так как сокет является двусторонним механизмом связи,
то нельзя предсказать заранее, когда произойдет разрыв соединения – во время
чтения или записи. Поэтому нужно учитывать оба возможных варианта.
Если процесс пытается записать данные в оборванный сокет при помощи вызова
write или send, то он получит сигнал SIGPIPE, который может быть пере
хвачен соответствующим обработчиком сигнала. При чтении обрыв диагностиру
ется проще.
В случае разорванной связи вызов read или recv возвращает нулевое значе
ние. Поэтому для вызовов read и recv необходимо всегда проверять возвращае
мое значение, чтобы не зациклиться при приеме данных.
Закрываются сокеты так же, как и обычные дескрипторы файлового ввода/
вывода, – при помощи системного вызова close. Для сокета типа SOCK_STREAM
ядро гарантирует, что все записанные в сокет данные будут переданы принимаю
щему процессу. Это может вызвать блокирование операции закрытия сокета до
тех пор, пока данные не будут доставлены. (Если сокет имеет тип SOCK_DGRAM, то
сокет закрывается немедленно.)


Ошибка bind: к данному адресу уже привязан сокет!

Unlink: разрыв связи сокета(файлового дескриптора?) с каталогом

Что нужно чтобы разблокировался accept???